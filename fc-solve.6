'\" t
.\"     Title: fc-solve
.\"    Author: Shlomi Fish <shlomif@cpan.org>
.\" Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
.\"      Date: 2018-10-27
.\"    Manual: \ \&
.\"    Source: \ \&
.\"  Language: English
.\"
.TH "FC\-SOLVE" "6" "2018\-10\-27" "\ \&" "\ \&"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------


.SH "NAME"
fc-solve \- automated solver for Freecell and related Solitiare variants
.SH "INTRODUCTION"

.sp
This is Freecell Solver version 5\&.0\&.x, a program that automatically solves most layouts of Freecell, and similar Solitaire variants as well as those of Simple Simon\&.
.sp
Freecell Solver is distributed under the MIT/Expat License ( http://en\&.wikipedia\&.org/wiki/MIT_License ), a free, permissive, open\-source license\&.
.sp
Note that the Freecell Solver source and Win32 binary distributions \fBdo not\fR provide a graphical user\-interface (GUI) and are primarily meant to be used by Solitaire researchers and software developers\&. If you\(cqre looking for a suitable GUI based on Freecell Solver, see our links at:
.sp
http://fc\-solve\&.shlomifish\&.org/links\&.html#front_ends
.sp
I hope you\(cqll enjoy using Freecell Solver, and make the best of it\&.
.sp
 \(em Shlomi Fish ( http://www\&.shlomifish\&.org/ )

.SH "BUILDING"

.sp
Read the file INSTALL\&.txt for information on how to do that\&.

.SH "USAGE"

.sp
The program is called "fc\-solve"\&. You invoke it like this:

.sp
.if n \{\
.RS 4
.\}
.nf
fc\-solve board_file
.fi
.if n \{\
.RE
.\}
.sp
board_file is the filename with a valid Freecell startup board\&. The file is built as follows:
.sp
It has the 8 Freecell stacks\&.
.sp
Each stack contains its cards separated by a whitespace and terminated with a newline character( it\(cqs important that the last stack will also be terminated with a newline !)\&. The cards in the line are ordered from the topmost card (= the card right on the virtual table and the one with the most cards placed on it) in the left, to the bottommost card in the right (= the card with no other cards placed on it)\&.
.sp
A card string contains the rank of the card followed by its suit\&. The card number is one of: A,1,2,3,4,5,6,7,8,9,10,J,Q,K\&. Alternatively, T can be used instead of 10\&. The card suit is one of: H,S,D,C (standing for Hearts, Spades, Diamonds and Clubs respectively)\&.
.sp
Here is an example board: (PySol/Microsoft board No\&. 24)

.sp
.if n \{\
.RS 4
.\}
.nf
4C 2C 9C 8C QS 4S 2H
5H QH 3C AC 3H 4H QD
QC 9S 6H 9H 3S KS 3D
5D 2S JC 5C JH 6D AS
2D KD 10H 10C 10D 8D
7H JS KH 10S KC 7C
AH 5S 6S AD 8H JD
7S 6C 7D 4D 8S 9D
.fi
.if n \{\
.RE
.\}
.sp
Visually, it appears as this:
.sp
[IMAGE] \&\s-2\u[1]\d\s+2 [Freecell Deal No. 24]
.sp
As can be seen, the four of clubs (4C), five of hearts (5H), etc\&. are at the bottom of the stacks and the start of the lines in the board input\&.
.sp
And another one: (PySol board No\&. 198246790)

.sp
.if n \{\
.RS 4
.\}
.nf
KD JH 5H 7D 9H KC 9D
3H JD 5D 8H QH 7H 2D
4D 3S QC 3C 6S QS KS
10C 9S 6D 9C QD 8S 10D
10S 8C 7S 10H 2C AS
8D AC AH 4H JC 4C
6H 7C 4S 5S 5C JS
AD KH 6C 2H 3D 2S
.fi
.if n \{\
.RE
.\}
.sp
Starting from Freecell Solver 3\&.14\&.x, a stack can also start with a leading colon (":")\&. This is to allow input from states as output by Freecell Solver using the \-p option\&.
.sp
You can specify the contents of the freecells by prefixing the line with "FC:" or with "Freecells:"\&. For example:

.sp
.if n \{\
.RS 4
.\}
.nf
FC: 3H QC
.fi
.if n \{\
.RE
.\}
.sp
will specify that the cards 3 of hearts and queen of clubs are present in the freecells\&. To specify an empty freecell use a "\-" as its designator\&.
.sp
If there\(cqs another "FC:" line, the previous line will be overridden\&.
.sp
You can specify the contents of the foundations by prefixing the line with "Founds:" or with "Foundations:" and then using a format as follows:

.sp
.if n \{\
.RS 4
.\}
.nf
Founds: H\-5 C\-A S\-0 D\-K
.fi
.if n \{\
.RE
.\}
.sp
Hence, the suit ID followed by a dash followed by the card number in the foundation\&. A suit that is not present will be assumed to be 0\&. Again, if there\(cqs more than one line like that, then the previous lines will be ignored and overridden\&.
.sp
The program will stop processing the input as soon as it read 8 lines of standard stacks\&. Therefore, it is recommended that the foundations and freecells lines will come at the beginning of the file\&.
.sp
The program will process the board and try to solve it\&. If it succeeds it will output the states from the initial board to its final solution to the standard output\&. If it fails, it will notify it\&.
.sp
For information about the various command\-line switches that Freecell Solver accepts, read the USAGE\&.txt file in this directory\&.
.sp
To solve Simple Simon boards append \-\-game simple_simon right after the "fc\-solve" program name\&.

.SH "THE BOARD GENERATION PROGRAMS"

.sp
Several programs which can generate the initial boards of various Freecell implementations can be found in the "board_gen/" sub\-directory\&. Read the README\&.txt file there for details on how they can be compiled and used\&.
.sp
In any case, they can save you the time of inputting the board yourself\&.

.SH "SOME COMPLETE EXAMPLES FOR LAYOUTS"

.sp
A layout in the middle of the MS Freecell deal No\&. 109 solution:

.sp
.if n \{\
.RS 4
.\}
.nf
Foundations: H\-6 C\-9 D\-2 S\-0
Freecells:  QS  3S  2S  KD
: 8H 3D
: KS QD JC
: AS 8D TD 7D JH TS 9D
: 7S 6D
: 5S
: KH QC JD TC 9H 8S 7H 6S 5D 4S
: KC QH JS TH 9S
: 4D
.fi
.if n \{\
.RE
.\}
.sp
Similar, but with an empty Freecell:

.sp
.if n \{\
.RS 4
.\}
.nf
Foundations: H\-6 C\-9 D\-2 S\-0
Freecells:  QS  3S  \-  KD
: 8H 3D 2S
: KS QD JC
: AS 8D TD 7D JH TS 9D
: 7S 6D
: 5S
: KH QC JD TC 9H 8S 7H 6S 5D 4S
: KC QH JS TH 9S
: 4D
.fi
.if n \{\
.RE
.\}
.sp
Likewise, only without leading colons where unnecessary:

.sp
.if n \{\
.RS 4
.\}
.nf
Foundations: H\-6 C\-9 D\-2 S\-0
Freecells:  QS  3S  \-  KD
8H 3D 2S
KS QD JC
AS 8D TD 7D JH TS 9D
7S 6D
5S
KH QC JD TC 9H 8S 7H 6S 5D 4S
KC QH JS TH 9S
4D
.fi
.if n \{\
.RE
.\}
.sp

.SH "HOW TO READ THE SOLUTIONS"

.sp
The file USAGE\&.txt covers all of Freecell Solver\(cqs command line options, but it may be too exhaustive for casual users\&. As a result, here is a shorter tutorial\&. First of all whenever invoking fc\-solve one should add the flags \-p \-t \-sam \-sel which will make the solution easier to understand\&. Then, assuming the board could be successfully solved, one will be given the layouts in the solution (in the format given above) vis\-a\-vis with the moves as the string\&. Note that the indexes of the resources given in the moves are 0\-based rather than the more natural 1\-based notation\&.

.SH "THE PROGRAMS"

.sp
Most command\-line switches have two versions:

.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

A short POSIX one which is a dash followed by a letter or a few\&. This option must come standalone and not clustered:
\-sam
is not equivalent to specifying
\-s,
\-a
and
\-m\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

A long switch which is two dashes followed by the command string\&. For example:
\-\-prelude,
\-\-st\-name\&.
.RE
.sp
If command line arguments have parameters, they are followed in separate parameters \- Freecell Solver won\(cqt recognise a parameter preceded by an equal sign\&. \-\-st\-name=myname is invalid, while \-\-st\-name myname is OK\&.
.SS "The Scope of the Options"

.sp
The scope of the options is mentioned along with them\&. Options can be:

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

Global \- affects all the soft\-threads\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

Instance\-specific \- affects an instance (separated by the
\-\-next\-instance
option below)\&. Each instance consists of several flares\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

Flare\-specific \- affects the current flare (separated by the
\-\-next\-flare
option below\&. Each flare consists of several hard threads\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

Hard\-thread\-specific \- affects the current hard thread (separated by the
\-\-next\-hard\-thread
option below\&. Each hard thread consists of several soft threads\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

Soft\-thread\-specific \- affects only the current soft thread\&.
.RE


.SH "GETTING HELP"

.SS "\-h , \-\-help"

.sp
\fBGlobal\fR
.sp
This option displays a help text on the screen\&. This help gives a help display summarizing some ways to use the program and get more help\&.

.SS "\-\-version"

.sp
\fBGlobal\fR
.sp
This option displays the version number of the components that make the executable (and then exits)\&.

.SS "\-\-help\-configs"

.sp
\fBGlobal\fR
.sp
Some help on the various configurations of Freecell Solver\&.

.SS "\-\-help\-options"

.sp
\fBGlobal\fR
.sp
A help screen giving an overview of all available options\&.

.SS "\-\-help\-real\-help"

.sp
\fBGlobal\fR
.sp
Explains how to change the default help screen to a different one\&.

.SS "\-\-help\-short\-sol"

.sp
\fBGlobal\fR
.sp
How to generate shorter solutions\&.

.SS "\-\-help\-summary"

.sp
\fBGlobal\fR
.sp
The default help screen\&.


.SH "OUTPUT OPTIONS"

.SS "\-p , \-\-parseable\-output"

.sp
\fBGlobal\fR
.sp
This option will display the columns in a format that can be more easily manipulated by text\-processing programs such as grep or perl\&. Namely, The freecells will be displayed in one line, and the foundations in a separate line\&. Plus, Each column will be displayed horizontally, in its own line, while beginning with a :\&.

.SS "\-t , \-\-display\-10\-as\-t"

.sp
\fBGlobal\fR
.sp
This option will display the 10 cards as a capital T +instead of a +10\&. Thus, the cards will be more properly aligned\&.
.sp
For example, here is a command line using \-p and \-t:

.sp
.if n \{\
.RS 4
.\}
.nf
$ pi\-make\-microsoft\-freecell\-board 24 | fc\-solve \-p \-t
\-=\-=\-=\-=\-=\-=\-=\-=\-=\-=\-=\-

Foundations: H\-0 C\-0 D\-0 S\-0
Freecells:
: 4C 2C 9C 8C QS 4S 2H
: 5H QH 3C AC 3H 4H QD
: QC 9S 6H 9H 3S KS 3D
: 5D 2S JC 5C JH 6D AS
: 2D KD TH TC TD 8D
: 7H JS KH TS KC 7C
: AH 5S 6S AD 8H JD
: 7S 6C 7D 4D 8S 9D


====================

Foundations: H\-0 C\-0 D\-0 S\-A
Freecells:
: 4C 2C 9C 8C QS 4S 2H
: 5H QH 3C AC 3H 4H QD
: QC 9S 6H 9H 3S KS 3D
: 5D 2S JC 5C JH 6D
: 2D KD TH TC TD 8D
: 7H JS KH TS KC 7C
: AH 5S 6S AD 8H JD
: 7S 6C 7D 4D 8S 9D
.fi
.if n \{\
.RE
.\}
.sp

.SS "\-c , \-\-canonized\-order\-output"

.sp
\fBGlobal\fR
.sp
Freecell Solver re\-arranges the stacks and freecells in a given state according to their first card\&. It keeps their actual position in a separate place, but internally it uses their canonized place\&. Use this option, if you want Freecell Solver to display them in that order\&. One should be warned that that way the place of a given stack in the board will not be preserved throughout the solution\&.

.SS "\-m , \-\-display\-moves"

.sp
\fBGlobal\fR
.sp
This option will display the moves instead of the intermediate states\&. Each move will be displayed in a separate line, in a format that is human\-readable, but that can also be parsed and analyzed by a computer program with some effort on the programmer\(cqs part\&.
.sp
For example:

.sp
.if n \{\
.RS 4
.\}
.nf
$ pi\-make\-microsoft\-freecell\-board 24 | fc\-solve \-m | head \-30
\-=\-=\-=\-=\-=\-=\-=\-=\-=\-=\-=\-

Move a card from stack 3 to the foundations

====================

Move a card from stack 6 to freecell 0

====================

Move a card from stack 6 to freecell 1
.fi
.if n \{\
.RE
.\}
.sp

.SS "\-sn , \-\-standard\-notation"

.sp
\fBGlobal\fR
.sp
This option will display the moves in standard notation in which every move consists of two characters and there are ten moves in a line\&. Naturally, this option will only become apparent if the display moves is specified\&. (it does not implicitly specify it, though)\&.
.sp
For more information regarding standard notation refer to the following web\-page:
.sp
http://home\&.earthlink\&.net/~fomalhaut/freecell\&.html

.SS "\-snx , \-\-standard\-notation\-extended"

.sp
\fBGlobal\fR
.sp
This option is similar to the previous one, except that when a sequence move is made to an empty stack with more than one card in the sequence, the move will be followed with "v" and the number of cards moved in hexadecimal\&.

.SS "\-sam , \-\-display\-states\-and\-moves"

.sp
\fBGlobal\fR
.sp
This option will display both the intermediate states and the moves that are needed to move from one to another\&. The standard notation option applies to it to\&.

.sp
.if n \{\
.RS 4
.\}
.nf
$ pi\-make\-microsoft\-freecell\-board 24 | fc\-solve \-sam \-p \-t | head \-50
\-=\-=\-=\-=\-=\-=\-=\-=\-=\-=\-=\-

Foundations: H\-0 C\-0 D\-0 S\-0
Freecells:
: 4C 2C 9C 8C QS 4S 2H
: 5H QH 3C AC 3H 4H QD
: QC 9S 6H 9H 3S KS 3D
: 5D 2S JC 5C JH 6D AS
: 2D KD TH TC TD 8D
: 7H JS KH TS KC 7C
: AH 5S 6S AD 8H JD
: 7S 6C 7D 4D 8S 9D


====================

Move a card from stack 3 to the foundations

Foundations: H\-0 C\-0 D\-0 S\-A
Freecells:
: 4C 2C 9C 8C QS 4S 2H
: 5H QH 3C AC 3H 4H QD
: QC 9S 6H 9H 3S KS 3D
: 5D 2S JC 5C JH 6D
: 2D KD TH TC TD 8D
: 7H JS KH TS KC 7C
: AH 5S 6S AD 8H JD
: 7S 6C 7D 4D 8S 9D


====================

Move a card from stack 6 to freecell 0

Foundations: H\-0 C\-0 D\-0 S\-A
Freecells:  JD
: 4C 2C 9C 8C QS 4S 2H
: 5H QH 3C AC 3H 4H QD
: QC 9S 6H 9H 3S KS 3D
: 5D 2S JC 5C JH 6D
: 2D KD TH TC TD 8D
: 7H JS KH TS KC 7C
: AH 5S 6S AD 8H
: 7S 6C 7D 4D 8S 9D


====================

Move a card from stack 6 to freecell 1
.fi
.if n \{\
.RE
.\}
.sp

.SS "\-pi , \-\-display\-parent\-iter"

.sp
\fBGlobal\fR
.sp
This option (assuming the \-s and \-i options are specified) will also display the iteration index of the state from which the current state was derived\&. This is especially useful for BeFS (so\-called a\-star) or BFS scans\&.

.SS "\-o [filename] , \-\-output [filename]"

.sp
\fBGlobal\fR
.sp
Outputs to a file instead of standard output\&. So for example:

.sp
.if n \{\
.RS 4
.\}
.nf
$ fc\-solve \-o 2405\&.solution\&.txt 2405\&.board
.fi
.if n \{\
.RE
.\}
.sp
Will put the solution to the file in 2405\&.board in the file 2405\&.solution\&.txt \&. This will also be done using:

.sp
.if n \{\
.RS 4
.\}
.nf
$ fc\-solve \-\-output 2405\&.solution\&.txt 2405\&.board
.fi
.if n \{\
.RE
.\}
.sp

.SS "\-sel , \-\-show\-exceeded\-limits"

.sp
\fBGlobal\fR
.sp
This option will display a different status message ("Iterations count exceeded\&.") instead of "I could not solve this game\&." in case the iterations count was exceeded\&. This is recommended because the "I could not solve this game\&." message can also mean that the entire game graph was fully traversed (within the limitations of the specified moves\*(Aq types) and so no solution is possible\&.
.sp
This option is not the default, to retain compatibility with previous versions of Freecell Solver, and was added in version 3\&.12\&.0 of fc\-solve\&.

.SS "\-hoi , \-\-hint\-on\-intractable"

.sp
\fBGlobal\fR
.sp
Presents the moves to the intermediate reached state, if the maximal number of iterations was reached without a conclusion (= "intractable")\&.
.sp
This option is not the default, to retain compatibility with previous versions of Freecell Solver, and was added in version 4\&.20\&.0 of fc\-solve\&.


.SH "GAME VARIANTS OPTIONS"

.SS "\-\-freecells\-num [Number of Freecells]"

.sp
\fBGlobal\fR
.sp
This option specifies the number of freecells which are available to the program\&. Freecell Solver can use any number of freecells as long as it does not exceed its maximal number\&.
.sp
This maximum is hard\-coded into the program, and can be specified at compile\-time by modifying the file config\&.h\&. See the file INSTALL (or alternatively INSTALL\&.html) for details\&.

.SS "\-\-stacks\-num [Number of Stacks]"

.sp
\fBGlobal\fR
.sp
This option specifies the number of stacks present in the board\&. Again, this number cannot exceed the maximal number of stacks, which can be specified in the file config\&.h during compile\-time of Freecell Solver\&.

.SS "\-\-decks\-num [Number of Decks]"

.sp
\fBGlobal\fR
.sp
This options specifies how many decks are found in the board\&. This number cannot exceed the maximal number of decks, which can be specified by the Freecell Solver build system\&.

.SS "\-\-sequences\-are\-built\-by {suit|alternate_color|rank}"

.sp
\fBGlobal\fR
.sp
This option specifies whether a card sequence is built by suit or by alternate colour or by rank regardless of suit\&.

.SS "\-\-sequence\-move {limited|unlimited}"

.sp
\fBGlobal\fR
.sp
This option specifies whether the sequence move is limited by the number of freecells or vacant stacks or not\&.

.SS "\-\-empty\-stacks\-filled\-by {kings|none|all}"

.sp
\fBGlobal\fR
.sp
Specifies which cards can fill an empty stack\&.

.SS "\-\-game [game] , \-\-preset [game] , \-g [game]"

.sp
\fBGlobal\fR
.sp
Specifies the type of game\&. Each preset implies several of the settings options above and sometimes even the moves\(cq order below\&. The default configuration is for Freecell\&.
.sp
Available presets:
.TS
allbox tab(:);
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt.
T{
.sp
bakers_dozen
T}:T{
.sp
Baker\(cqs Dozen
T}
T{
.sp
bakers_game
T}:T{
.sp
Baker\(cqs Game
T}
T{
.sp
beleaguered_castle
T}:T{
.sp
Beleaguered Castle
T}
T{
.sp
citadel
T}:T{
.sp
Citadel
T}
T{
.sp
cruel
T}:T{
.sp
Cruel
T}
T{
.sp
der_katz
T}:T{
.sp
Der Katzenschwanz
T}
T{
.sp
die_schlange
T}:T{
.sp
Die Schlange
T}
T{
.sp
eight_off
T}:T{
.sp
Eight Off
T}
T{
.sp
fan
T}:T{
.sp
Fan
T}
T{
.sp
forecell
T}:T{
.sp
Forecell
T}
T{
.sp
freecell
T}:T{
.sp
Freecell (default)
T}
T{
.sp
good_measure
T}:T{
.sp
Good Measure
T}
T{
.sp
ko_bakers_game
T}:T{
.sp
Kings\*(Aq Only Baker\(cqs Game
T}
T{
.sp
relaxed_freecell
T}:T{
.sp
Relaxed Freecell
T}
T{
.sp
relaxed_sehaven
T}:T{
.sp
Relaxed Seahaven Towers
T}
T{
.sp
seahaven
T}:T{
.sp
Seahaven Towers
T}
T{
.sp
simple_simon
T}:T{
.sp
Simple Simon
T}
T{
.sp
streets_and_alleys
T}:T{
.sp
Streets and Alleys
T}
.TE
.sp 1
.sp
Note: in order to solve Der Katzenschwanz and Die Schlange I recommend you compile Freecell Solver with the INDIRECT_STACK_STATES option, or else it will consume much more memory\&. For details consult the file INSTALL\&.

.SS "Examples"

.sp
To solve PySol Eight Off game No\&. 1,000 type:

.sp
.if n \{\
.RS 4
.\}
.nf
$ make_pysol_freecell_board\&.py 1000 eight_off | fc\-solve \-g eight_off
.fi
.if n \{\
.RE
.\}
.sp
To solve PySol Baker\(cqs Game No\&. 50, type:

.sp
.if n \{\
.RS 4
.\}
.nf
$ make_pysol_freecell_board\&.py 50 bakers_game | fc\-solve \-g bakers_game
.fi
.if n \{\
.RE
.\}
.sp
If you want to solve a game similar to Freecell only with sequences built by rank, and unlimited sequence move, do:

.sp
.if n \{\
.RS 4
.\}
.nf
$ fc\-solve \-g freecell \-\-sequences\-are\-built\-by rank \-\-sequence\-move unlimited
.fi
.if n \{\
.RE
.\}
.sp


.SH "SOLVING ALGORITHM OPTIONS"

.SS "\-mi [Iterations num] , \-\-max\-iters [Iterations num]"

.sp
\fBGlobal\fR
.sp
This parameter limits the maximal number of states to check\&. This will give a rough limit on the time spent to solve a given board\&.

.SS "\-md [Maximal depth] , \-\-max\-depth [Maximal depth]"

.sp
\fBNot currently implemented\fR
.sp
Freecell Solver recurses into the solution\&. This parameter specifies a maximal recursion depth\&. Generally speaking, it\(cqs not a good idea to set it, because that way several important intermediate states may become inaccessible\&.

.SS "\-mss [num] , \-\-max\-stored\-states [num]"

.sp
\fBGlobal\fR
.sp
Limits the number of the states stored by the program in the computer\(cqs memory\&. This differs from the maximal number of iterations in the sense, that it is possible that a stored state was not checked yet\&.

.SS "\-tmss [num] , \-\-trim\-max\-stored\-states [num]"

.sp
\fBInstance\-wide\fR
.sp
This also limits the number of trimmed stored states, but this time will try to trim them once the limit has been reached (which is time consuming and may cause states to be traversed again in the future)\&.

.SS "\-to [Moves\(cq Order] , \-\-tests\-order [Moves Order]"

.sp
\fBSoft\-thread\-specific\fR
.sp
This option specifies the order in which Freecell Solver will try the different types of moves (formerly termed "tests") that it can perform\&. Each move is specified by one character, and they are performed in the order in which they appear in the parameter string\&. You can omit moves by not including their corresponding characters in the string\&.
.sp
The moves along with their characters are:
.TS
allbox tab(:);
lt s
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt s
lt lt
lt lt
lt lt
lt lt
lt lt
lt s
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Freecell Moves:
T}
T{
.sp
\fI0\fR
T}:T{
.sp
put top stack cards in the foundations\&.
T}
T{
.sp
\fI1\fR
T}:T{
.sp
put freecell cards in the foundations\&.
T}
T{
.sp
\fI2\fR
T}:T{
.sp
put freecell cards on top of stacks\&.
T}
T{
.sp
\fI3\fR
T}:T{
.sp
put non\-top stack cards in the foundations\&.
T}
T{
.sp
\fI4\fR
T}:T{
.sp
move stack cards to different stacks\&.
T}
T{
.sp
\fI5\fR
T}:T{
.sp
move stack cards to a parent card on the same stack\&.
T}
T{
.sp
\fI6\fR
T}:T{
.sp
move sequences of cards onto free stacks\&.
T}
T{
.sp
\fI7\fR
T}:T{
.sp
put freecell cards on empty stacks\&.
T}
T{
.sp
\fI8\fR
T}:T{
.sp
move cards to a different parent\&.
T}
T{
.sp
\fI9\fR
T}:T{
.sp
empty an entire stack into the freecells\&.
T}
T{
.sp
\fIj\fR
T}:T{
.sp
put freecell cards on empty stacks and right away put cards on top\&.
T}
T{
.sp
Atomic Freecell Moves:
T}
T{
.sp
\fIA\fR
T}:T{
.sp
move a stack card to an empty stack\&.
T}
T{
.sp
\fIB\fR
T}:T{
.sp
move a stack card to a parent on a different stack\&.
T}
T{
.sp
\fIC\fR
T}:T{
.sp
move a stack card to a freecell\&.
T}
T{
.sp
\fID\fR
T}:T{
.sp
move a freecell card to a parent\&.
T}
T{
.sp
\fIE\fR
T}:T{
.sp
move a freecell card to an empty stack\&.
T}
T{
.sp
Simple Simon Moves:
T}
T{
.sp
\fIa\fR
T}:T{
.sp
move a full sequence to the foundations\&.
T}
T{
.sp
\fIb\fR
T}:T{
.sp
move a sequence to a true parent of his\&.
T}
T{
.sp
\fIc\fR
T}:T{
.sp
move a whole stack sequence to a false parent (in order to clear the stack)
T}
T{
.sp
\fId\fR
T}:T{
.sp
move a sequence to a true parent that has some cards above it\&.
T}
T{
.sp
\fIe\fR
T}:T{
.sp
move a sequence with some cards above it to a true parent\&.
T}
T{
.sp
\fIf\fR
T}:T{
.sp
move a sequence with a junk sequence above it to a true parent that has some cards above it\&.
T}
T{
.sp
\fIg\fR
T}:T{
.sp
move a whole stack sequence to a false parent which has some cards above it\&.
T}
T{
.sp
\fIh\fR
T}:T{
.sp
move a sequence to a parent on the same stack\&.
T}
T{
.sp
\fIi\fR
T}:T{
.sp
move any sequence to a false parent (using it may make the solution much slower)\&.
T}
.TE
.sp 1
.sp
Manipulating the moves order can be very helpful to the quick solution of a given board\&. If you found that a certain board cannot be solved in after a long time or in a certain maximal number of iterations, you should try different moves\*(Aq orders\&. Usually, one can find a moves order that solves a board very quickly\&.
.sp
Note that this moves order usually makes sense only for the Soft\-DFS and Random DFS scans (see the \-\-method option below)\&.
.sp
Also note that Freecell moves are not suitable for solving Simple Simon games and Simple Simon moves are not suitable for solving anything except Simple Simon\&.
.sp
Moves can be grouped together into groups using parenthesis (e\&.g: "(0123)") or square brackets ("[012][3456789]")\&. Such grouping is only relevant to the Random DFS scan (see below)\&. A group may optionally be followed by the equal sign "=" and by an ordering specifier\&. If one specifies "=rand()", then the derived states will be randomised based on the seed (which is what happens if no equal sign is specified)\&. On the other hand, if one specifies something like "=asw(5,0,5,0,0,5)", then the numbers inside the parentheses will be treated as weights for the same ordering function used by the \-asw flag (see below)\&.

.SS "\-dto2 [Min Depth],[Moves\*(Aq Order] , \-\-depth\-tests\-order2 [Min Depth],[Moves\*(Aq Order]"

.sp
\fBSoft\-thread\-specific\fR
.sp
Sets the Moves\*(Aq order starting from the minimal depth onwards\&. This way, if a Soft\-DFS scan recurses deeply into the game, it will use a different moves\*(Aq order\&.
.sp
Note that if you set the moves\*(Aq order of a minimal depth of say 50, then it will override all the moves\*(Aq order of 50 and above\&. As a result, it is recommended that you set the minimal depth moves order in an increasing depth\&.
.sp
It should be noted that the \-to or \-\-tests\-order option above is equivalent to using this option with a minimal depth of 0\&.
.sp
Here are some examples:

.sp
.if n \{\
.RS 4
.\}
.nf
\-to 0123456789 \-dto2 30,0138924567
.fi
.if n \{\
.RE
.\}
.sp
This sets the moves\*(Aq order to 0123456789 for all depths below 30 and to 0138924567 for all depths above it\&.

.sp
.if n \{\
.RS 4
.\}
.nf
\-to 0123457 \-dto2 10,750123 \-dto2 25,710235
.fi
.if n \{\
.RE
.\}
.sp
This sets the moves\*(Aq order to 0123457 for depths \-9 (those below 10), to 750123 for depths 10\-24, and to 710235 for the depths 25 onwards\&.

.sp
.if n \{\
.RS 4
.\}
.nf
\-to 0123457 \-dto2 "10,[012357]=asw(1)"
.fi
.if n \{\
.RE
.\}
.sp
This sorts the moves starting from 10 onward based on the asw() function\&.

.sp
.if n \{\
.RS 4
.\}
.nf
\-to 0123457 \-dto2 "10,[012357]=rand()"
.fi
.if n \{\
.RE
.\}
.sp
This randomises the moves from 10 onward\&.

.sp
.if n \{\
.RS 4
.\}
.nf
\-to 0123457 \-dto2 "10,[012357]"
.fi
.if n \{\
.RE
.\}
.sp
This does the same thing as the previous example\&.
.sp
\fBNote\fR : This option should be used instead of the older \-dto option given below which mutilates the moves order parameter and is still provided for backward compatibility\&.

.SS "\-dto [Min Depth],[Moves\*(Aq Order] , \-\-depth\-tests\-order [Min Depth],[Moves\*(Aq Order]"

.sp
This is equivalent to specifying \-dto2 [Min Depth],[Min Depth],[Moves\*(Aq Order] \- i\&.e: the "[Min Depth]," string is prefixed to the given moves order\&.
.sp
This option is provided for backward compatibility with older versions of Freecell Solver\&.

.SS "\-me [Solving Method] , \-\-method [Solving Method]"

.sp
\fBSoft\-thread\-specific\fR
.sp
This option specifies the solving method that will be used to solve the board\&. Currently, the following methods are available:

.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

a\-star
\- A Best\-First\-Search scan (not "A*" as it was once thought to be)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

bfs
\- A Breadth\-First Search (or BFS) scan
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

dfs
\- A Depth\-First Search (or DFS) scan
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

random\-dfs
\- A randomized DFS scan
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

patsolve
\- uses the scan of patsolve\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

soft\-dfs
\- A "soft" DFS scan
.RE
.sp
Starting from recent Freecell Solver versions there is no difference between dfs and soft\-dfs\&. In earlier versions, use of soft\-dfs is recommended\&. random\-dfs is similar to soft\-dfs only it determines to which states to recurse into randomly\&. Its behaviour will differ depending on the seed you supply to it\&. (see the "\-seed" option below\&.)
.sp
BFS does not yield good results, and a\-star has a mixed behaviour, so for the time being I recommend using Soft\-DFS or Random\-DFS\&.
.sp
The Random\-DFS scan processes every moves\*(Aq random group, randomizes the states that it found and recurses into them one by one\&. Standalone moves that do not belong to any group, are processed in a non\-random manner\&.

.SS "\-asw [BeFS Weights] , \-\-a\-star\-weight [BeFS Weights]"

.sp
\fBSoft\-thread\-specific\fR
.sp
Specify weights for the a\-star (= "Best\-First Search") scan, assuming it is used\&. The parameter should be a comma\-separated list of numbers, each one is proportional to the weight of its corresponding test\&.
.sp
The numbers are, in order:

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

The number of cards out\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

The maximal sequence move\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

The number of cards under sequences\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

The length of the sequences which are found over renegade cards\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

The depth of the board in the solution\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

The negative of the number of cards that are not placed above their parents\&. To get the irreversibility depth, give equal weight to this weight and to the number of cards out\&.
.RE
.sp
The default weights are respectively: {0\&.5, 0, 0\&.3, 0, 0\&.2, 0}

.SS "\-seed [Seed Number]"

.sp
\fBSoft\-thread\-specific\fR
.sp
Specifies a seed to be used by Freecell Solver\(cqs internal random number generator\&. This seed may alter the behaviour and speed of the random\-dfs scan\&.

.SS "\-\-set\-pruning [Pruning] , \-sp [Pruning]"

.sp
\fBSoft\-thread\-specific\fR
.sp
This option sets the pruning algorithm for the soft thread\&. Current valid values are only the empty string ("") for no pruning and r:tf (short for "Run: to foundations") for Horne\(cqs rule\&. See:
.sp
https://groups\&.yahoo\&.com/neo/groups/fc\-solve\-discuss/conversations/topics/214

.SS "\-opt , \-\-optimize\-solution"

.sp
\fBFlare\-wide\fR
.sp
This option instructs Freecell Solver to try and optimize the solution path so it will have a smaller number of moves\&.

.SS "\-opt\-to [moves order] , \-\-optimization\-tests\-order [moves order]"

.sp
\fBFlare\-wide\fR
.sp
This argument specifies the moves order for the optimization scan, in case it should be different than an order that contains all the moves that were used in all the normal scans\&.

.SS "\-\-reparent\-states"

.sp
\fBFlare\-wide\fR
.sp
This option specifies that states that were encountered whose depth in the states graph can be improved should be reparented to the new parent\&. This option can possibly make solutions shorter\&.

.SS "\-\-calc\-real\-depth"

.sp
\fBFlare\-wide\fR
.sp
This option becomes effective only if \-\-reparent\-states is specified\&. What it does, is explicitly calculate the depth of the state by tracing its path to the initial state\&. This may make depth consideration more accurate\&.

.SS "\-\-patsolve\-x\-param [pos],[value]"

.sp
\fBSoft\-thread\-specific\fR
.sp
Sets the patsolve\(cqs scan X param (an integer) in position "pos" into "value"\&.
.sp
Examples:

.sp
.if n \{\
.RS 4
.\}
.nf
\-\-patsolve\-x\-param 0,5
\-\-patsolve\-x\-param 2,100
.fi
.if n \{\
.RE
.\}
.sp

.SS "\-\-patsolve\-y\-param [pos],[value]"

.sp
\fBSoft\-thread\-specific\fR
.sp
Sets the patsolve Y param (a floating point number) in position "pos" into "value"\&.
.sp
Examples:

.sp
.if n \{\
.RS 4
.\}
.nf
\-\-patsolve\-y\-param 0,0\&.5
\-\-patsolve\-y\-param 1,103\&.2
.fi
.if n \{\
.RE
.\}
.sp


.SH "RUNNING SEVERAL SCANS IN PARALLEL"

.sp
Starting from Version 2\&.4\&.0, Freecell Solver can run several scans in parallel on the same state collection\&. Each scan resides in its own "Soft Thread"\&. By specifying several soft threads on the command line one can create use several parallel scans\&. Once one of the scans reaches a solution, the solution will be displayed\&.
.SS "\-nst , \-\-next\-soft\-thread"

.sp
\fBHard\-thread\-specific\fR
.sp
This option creates a new soft\-thread and makes the following scan\-specific options initialize it\&. For example:

.sp
.if n \{\
.RS 4
.\}
.nf
$ fc\-solve \-\-method a\-star \-nst \-\-method soft\-dfs \-to 0123467 myboard\&.txt
.fi
.if n \{\
.RE
.\}
.sp
will run an BeFS scan and a Soft\-DFS scan with a moves order of 0123467 on myboard\&.txt\&.

.SS "\-step [Step] , \-\-soft\-thread\-step [Step]"

.sp
\fBSoft\-thread\-specific\fR
.sp
This option will set the number of iterations with which to run the soft thread before switching to the next one\&. By specifying a larger step, one can give a certain scan a longer run\-time and a higher priority\&.
.sp
\fBNote:\fR after some experimentation, we have concluded that the \-\-prelude option normally yields better results, but \-step can be used as a fallback\&.

.SS "\-nht , \-\-next\-hard\-thread"

.sp
\fBFlare\-wide\fR
.sp
This argument lets one initialize the next hard thread\&. If Freecell Solver was compiled with such support, then it is possible to run each hard thread in its own system thread\&. Each hard\-thread contains one or more soft threads\&.

.SS "\-\-st\-name [soft thread name]"

.sp
\fBSoft\-thread\-specific\fR
.sp
This argument sets the name used to identify the current soft thread\&. This name can later be used to construct the prelude (see below)\&.

.SS "\-\-prelude [\ei1@st1{,\ei2@st2{,\ei3@st3\&...\:}}]"

.sp
\fBHard\-thread\-specific\fR
.sp
Sets the prelude for the hard thread\&. At the beginning of the search, the hard thread plays a static sequence of iterations at each of the soft threads specified in the prelude, for the number of iterations specified\&.
.sp
For example, if you had three soft threads named "foo", "bar" and "rin", then the following prelude:

.sp
.if n \{\
.RS 4
.\}
.nf
\-\-prelude 500@foo,1590@bar,100@foo,200@rin
.fi
.if n \{\
.RE
.\}
.sp
Will run 500 iterations in "foo", then 1590 in "bar", then 100 in "foo" again, and then 200 in "rin"\&. After the prelude finishes, the hard thread would run the scans one after the other in the sequence they were defined for their step number\&.

.SS "\-\-scans\-synergy {none|dead\-end\-marks}"

.sp
\fBFlare\-wide\fR
.sp
Specifies the synergy between the various scans, or how much they cooperate between themselves\&. none means they do not cooperate and only share the same memory resources\&. dead\-end\-marks means they try to mark states that they have withdrawn from, and states whose all their derived states are such, as "dead ends"\&. This may or may not improve the speed of the solution\&.

.SS "\-ni , \-\-next\-instance"

.sp
\fBGlobal\fR
.sp
This option allows one to run two or more separate solvers one after the other\&. If the first one returned an unsolvable verdict, then the second one would run and so on\&. One use of it is to run an atomic moves scan after a meta\-moves scan, so we will always get an accurate verdict and still enjoy some of the speed benefits of the meta\-moves scan\&.

.SS "\-nf , \-\-next\-flare"

.sp
\fBInstance\-wide\fR
.sp
Each instance contains several flares\&. Flares are various alternative scans, that are ran one after another, as specified in the \-\-flares\-plan below or defaulting to running only the first flare (which isn\(cqt very useful)\&. Out of all the flares that are successful in solving a board, Freecell Solver picks the one with the shortest solution\&.

.SS "\-\-flare\-name [flare name]"

.sp
\fBFlare\-wide\fR
.sp
This is a name that identifies the flare for use in the flares\*(Aq plan\&.

.SS "\-\-flares\-plan [flare plan]"

.sp
\fBInstance\-wide\fR
.sp
This instance\-wide parameter gives a plan for the flares as a big string\&. Here are some examples:

.sp
.if n \{\
.RS 4
.\}
.nf
\-\-flares\-plan "RunIndef:FlareyFlare"
.fi
.if n \{\
.RE
.\}
.sp
This plan will run the flare with the name FlareyFlare indefinitely, until it terminates\&. Once a RunIndef action is encountered, the rest of the plan is ignored\&.

.sp
.if n \{\
.RS 4
.\}
.nf
\-\-flares\-plan "Run:500@MyFlare,Run:2000@FooFlare"
.fi
.if n \{\
.RE
.\}
.sp
Runs MyFlare for 500 iterations and FooFlare for 2,000 iterations\&. Note that both flares will be run and won\(cqt share any resources between them, and then the minimal solution out of both flares (or only those that finished )\&. If no flares finished, then Freecell Solver will run them both again for the same number of iterations each, until at least one finishes (or it ran out of the iterations\*(Aq limit)\&.

.sp
.if n \{\
.RS 4
.\}
.nf
\-\-flares\-plan "Run:500@dfs,Run:1500@befs,CP:,Run:10000@funky"
.fi
.if n \{\
.RE
.\}
.sp
This runs the flares identified by dfs and befs and then see if a solution was reached ("CP:" stands for \fB"checkpoint"\fR), and if so yield it\&. If both flares did not reach a solution yet, or failed to solve the board, it will run the flare funky for 10,000 iterations and yield its solution\&. And like the previous case, this solution will loop after it ended for as long as the no flare solved the board or the program did not run out of iterations\&.
.sp
Using checkpoints one can yield a possibly sub\-optimal (as far as solution length is concerned) solution that will still solve faster than letting all the flares run\&.

.SS "\-\-flares\-choice [choice]"

.sp
\fBGlobal\fR
.sp
This dictates how to choose the winning flare based on if more than one yielded a solution\&. Possible options are:

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

\-\-flares\-choice fc_solve
\- the default, which picks up the solutions based on the length of the solution in Freecell Solver\(cqs moves\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

\-\-flares\-choice fcpro
\- picks up the shortest solution based on the number of Freecell Pro moves, while not considering implicit moves to the foundations using Horne\(cqs Prune / Raymond Prune\&.
.RE

.SS "\-fif [factor] , \-\-flares\-iters\-factor [factor]"

.sp
\fBGlobal\fR
.sp
Sets a global, floating\-point number, factor to multiply all the iterations counts in the flares plans\&. The higher it is, the longer the scans will take, but there is a greater chance more of them will succeed, and, as a result, the solution may be shorter\&.
.sp
As an example, the following:

.sp
.if n \{\
.RS 4
.\}
.nf
\-\-flares\-plan "Run:500@MyFlare,Run:2000@FooFlare" \-\-flares\-iters\-factor 2
.fi
.if n \{\
.RE
.\}
.sp
Is equivalent to:

.sp
.if n \{\
.RS 4
.\}
.nf
\-\-flares\-plan "Run:1000@MyFlare,Run:4000@FooFlare"
.fi
.if n \{\
.RE
.\}
.sp
while:

.sp
.if n \{\
.RS 4
.\}
.nf
\-\-flares\-plan "Run:500@MyFlare,Run:2000@FooFlare" \-\-flares\-iters\-factor 0\&.5
.fi
.if n \{\
.RE
.\}
.sp
Is equivalent to:

.sp
.if n \{\
.RS 4
.\}
.nf
\-\-flares\-plan "Run:250@MyFlare,Run:1000@FooFlare"
.fi
.if n \{\
.RE
.\}
.sp

.SS "\-\-cache\-limit [cache limit]"

.sp
\fBGlobal\fR
.sp
This is a numeric limit to the LRU cache which only matters if Freecell Solver was compiled with FCS_RCS_STATES enabled\&. This value should be a positive integer and the higher it is, the more quickly it is likely that Freecell Solver will run, but it will also consume more memory\&. (The entire point of FCS_RCS_STATES is to conserve memory)\&.


.SH "META\-OPTIONS"

.SS "\-\-reset"

.sp
\fBGlobal\fR
.sp
This option resets the program to its initial state, losing all the configuration logic that was input to it up to that state\&. Afterwards, it can be set to a different configuration, again\&.

.SS "\-\-read\-from\-file [num_skip,]filename"

.sp
\fBGlobal\fR (but context\-specific)\&.
.sp
This option will read the configuration options from a file\&. The format of the file is similar to that used by the UNIX Bourne Shell\&. (i\&.e: spaces denote separate arguments, double\-quotes encompass arguments, backslash escapes characters)\&.
.sp
The filename can be preceded by an optional number of the arguments to skip followed by a comma\&. (the default is 0)

.SS "\-l [preset] , \-\-load\-config [preset]"

.sp
\fBGlobal\fR (but context\-specific)\&.
.sp
Reads the configuration specified by [preset] and configures the solver accordingly\&. A preset is a set of command line arguments to be analyzed in the place of this option\&. They are read from a set of presetrc files : one installed system\-wide, the other at $HOME/\&.freecell\-solver/presetrc and the third at the path specified by the FREECELL_SOLVER_PRESETRC environment variable\&. You can add more presets at any of these places\&. (refer to http://groups\&.yahoo\&.com/group/fc\-solve\-discuss/message/403 for information about their format)
.sp
Presets that are shipped with Freecell Solver:
.TS
allbox tab(:);
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt.
T{
.sp
abra\-kadabra
T}:T{
.sp
a meta\-moves preset
T}
T{
.sp
amateur\-star
T}:T{
.sp
a meta\-moves preset that yields solutions faster on average than three\-eighty\&.
T}
T{
.sp
blue\-yonder
T}:T{
.sp
a meta\-moves preset generated by a quota optimization algorithm\&.
T}
T{
.sp
children\-playing\-ball
T}:T{
.sp
a meta\-moves and flare\-based preset that tends to yield very short solution, but is very slow (solves only 3 boards per second on a Pentium 4 2\&.4GHz)\&.
T}
T{
.sp
conspiracy\-theory
T}:T{
.sp
a meta\-moves preset that yields solutions faster on average than amateur\-star\&.
T}
T{
.sp
cookie\-monster
T}:T{
.sp
a meta\-moves preset that yields solutions faster on average than one\-big\-family\&.
T}
T{
.sp
cool\-jives
T}:T{
.sp
a meta\-moves preset
T}
T{
.sp
crooked\-nose
T}:T{
.sp
an atomic\-moves preset (guarantees an accurate verdict)
T}
T{
.sp
enlightened\-ostrich
T}:T{
.sp
a meta\-moves preset (that depends on Freecell Solver 3\&.4\&.0 and above) that yields solutions faster on average than foss\-nessy\&.
T}
T{
.sp
fools\-gold
T}:T{
.sp
an atomic\-moves preset
T}
T{
.sp
foss\-nessy
T}:T{
.sp
a meta\-moves preset (that depends on Freecell Solver 3\&.2\&.0 and above) that yields solutions faster on average than the\-iglu\-cabal\&.
T}
T{
.sp
good\-intentions
T}:T{
.sp
runs "cool\-jives" and then "fools\-gold"
T}
T{
.sp
gooey\-unknown\-thing
T}:T{
.sp
a meta\-moves preset that aims to minimise the outcome solution\(cqs length\&.
T}
T{
.sp
hello\-world
T}:T{
.sp
a meta\-moves preset
T}
T{
.sp
john\-galt\-line
T}:T{
.sp
a meta\-moves preset
T}
T{
.sp
looking\-glass
T}:T{
.sp
a meta\-moves preset that yields solutions faster on average than cookie\-monster\&.
T}
T{
.sp
maliciously\-obscure
T}:T{
.sp
a meta\-moves and flare\-based preset that tends to yield very short solutions (even in comparison to children\-playing\-ball ) but is slow\&.
T}
T{
.sp
micro\-finance
T}:T{
.sp
a meta\-moves and flare\-based preset that tends to yield very short solutions (even in comparison to maliciously\-obscure ) but is even slower\&.
T}
T{
.sp
micro\-finance\-improved
T}:T{
.sp
a meta\-moves and flare\-based preset, based on micro\-finance that yields somewhat shorter solutions on average, and should not be slower\&.
T}
T{
.sp
one\-big\-family
T}:T{
.sp
a meta\-moves preset that yields solutions faster on average than conspiracy\-theory\&.
T}
T{
.sp
qualified\-seed
T}:T{
.sp
a meta\-moves and flare\-based preset, based on micro\-finance\-improved that yields somewhat shorter solutions on average, and should not be slower\&.
T}
T{
.sp
qualified\-seed\-improved
T}:T{
.sp
qualified\-seed with \-fif 5 and \-\-flares\-choice fcpro
T}
T{
.sp
rin\-tin\-tin
T}:T{
.sp
a meta\-moves preset
T}
T{
.sp
sand\-stone
T}:T{
.sp
an atomic\-moves preset that aims to minimise the outcome solution\(cqs length\&.
T}
T{
.sp
slick\-rock
T}:T{
.sp
run "gooey\-unknown\-thing" and then "sand\-stone"
T}
T{
.sp
sentient\-pearls
T}:T{
.sp
a meta\-moves and flares based preset with short solutions\&. Much faster than children\-playing\-ball but yields less optimal solutions\&.
T}
T{
.sp
tea\-for\-two
T}:T{
.sp
a meta\-moves preset optimized for two\-freecells\*(Aq Freecell games (although it can work on other Freecell\-like games as well)\&.
T}
T{
.sp
the\-iglu\-cabal
T}:T{
.sp
a meta\-moves preset that yields faster solutions on average than blue\-yonder\&.
T}
T{
.sp
the\-last\-mohican
T}:T{
.sp
a preset for solving Simple Simon\&. Yields less false negatives than the default one, but might be slower\&.
T}
T{
.sp
three\-eighty
T}:T{
.sp
a meta\-moves preset (that depends on Freecell Solver 3\&.4\&.0 and above) that yields solutions faster on average than enlightened\-ostrich\&.
T}
T{
.sp
toons\-for\-twenty\-somethings
T}:T{
.sp
an atomic\-moves preset that solves more boards efficiently than "fools\-gold"\&.
T}
T{
.sp
video\-editing
T}:T{
.sp
a meta\-moves and flare\-based preset, based on qualified\-seed that yields shorter solutions on average, but may be somewhat slower\&. Named to commemorate the earlier work of Adrian Ettlinger (1925\-2013) who later contributed to Freecell Solver and to Freecell research\&.
T}
T{
.sp
yellow\-brick\-road
T}:T{
.sp
a meta\-moves preset
T}
.TE
.sp 1
.sp
They can be abbreviated into their lowercase acronym (i\&.e: "ak" or "rtt")\&.


.SH "RUN\-TIME DISPLAY OPTIONS"

.SS "\-i , \-\-iter\-output"

.sp
\fBGlobal\fR
.sp
This option tells fc\-solve to print the iteration number and the recursion depth of every state which is checked, to the standard output\&. It\(cqs a good way to keep track of how it\(cqs doing, but the output slows it down a bit\&.

.SS "\-\-iter\-output\-step [step]"

.sp
\fBGlobal\fR
.sp
Prints the current iteration if \-i is specified, only every [step] steps, where [step] is a positive integer\&. For example, if you do fc\-solve \-i \-\-iter\-output\-step 100, you will see this:

.sp
.if n \{\
.RS 4
.\}
.nf
Iteration: 0
Iteration: 100
Iteration: 200
Iteration: 300
.fi
.if n \{\
.RE
.\}
.sp
This option has been added in Freecell Solver 4\&.20\&.0 and is useful for speeding up the runtime process, by avoiding excessive output\&.

.SS "\-s , \-\-state\-output"

.sp
\fBGlobal\fR
.sp
This option implies \-i\&. If specified, this option outputs the cards and formation of the board itself, for every state that is checked\&. "fc\-solve \-s" yields a nice real\-time display of the progress of Freecell Solver, but you usually cannot make what is going on because it is so fast\&.


.SH "SIGNAL COMBINATIONS"

.sp
If you are working on a UNIX or a similar system, then you can set some run\-time options in "fc\-solve" by sending it some signal combinations\&.
.sp
If you send the fc\-solve a single ABRT signal, then fc\-solve will terminate the scan prematurely, and report that the iterations\(cqs limit has been exceeded\&.
.sp
If you send the signal USR1, without sending any other signals before that, then fc\-solve will output the present number of iterations\&. This method is a good way to monitor an instance that takes a long time to solve\&.
.sp
If you send it the signal USR2 and then USR1, then fc\-solve will print the iteration number and depth on every state that it checks\&. It is the equivalent of specifying (or unspecifying) the option \-i/\-\-iter\-output\&.
.sp
If you send it two USR2 signals and then USR1, then fc\-solve will also print the board of every state\&. Again, this will only be done assuming the iteration output is turned on\&.

.SH "AUTHOR"
.PP
\fBShlomi Fish\fR <\&shlomif@cpan\&.org\&>
.RS 4
Author.
.RE
